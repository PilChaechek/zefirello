## Этап 1: Backend — Получение данных (Read)
- API Resource: Создать UserResource для преобразования данных (скрыть пароли, отформатировать даты).
- Controller (Index): Реализовать метод index в UserController с пагинацией.
- Route: Зарегистрировать защищенный маршрут api/users.

## Этап 2: Frontend — Отображение списка (Read)
Подключаем Vue к API.
- TypeScript Interface: Описать тип IUser, чтобы IDE помогала нам (Intellisense).
- Service Layer: Создать services/userService.ts (или useUsers composable) для запросов к API. Не пишем axios.get внутри компонентов!
- UI Table: Реализовать таблицу в UserIndexView.vue.
- Challenge: Сделать пагинацию (кнопки "Назад/Вперед").

## Этап 3: Backend — Создание (Create)
- Request Validation: Создать StoreUserRequest. Валидация — это ответственность бэкенда (email unique, password rules).
- Controller (Store): Реализовать метод store.

## Этап 4: Frontend — Форма создания (Create)
- UI Form: Создать кнопку "Добавить" и форму (в модалке Dialog или на отдельной странице).
- Form Validation: Прикрутить Zod + VeeValidate. (Валидируем и на фронте для UX, и на бэке для безопасности).

## Этап 5: Редактирование и Удаление (Update & Delete)
- Backend: Методы show (получить одного), update (сохранить) и destroy (удалить).
- Frontend: Страница/Модалка редактирования и кнопка удаления с подтверждением ("Вы уверены?").

# Имперсонация

1. Бэкенд (Laravel API)

А. Начало имперсонации (Логин под пользователем)

1. Создание нового API-маршрута:
    * Нужен новый защищенный маршрут, например, POST /api/v1/users/{user}/impersonate.
    * Этот маршрут будет принимать ID пользователя, под которым нужно авторизоваться.

2. Авторизация действия:
    * Доступ к этому маршруту должен быть строго ограничен. Только администраторы могут его использовать. Это реализуется через middleware или Gate/Policy в Laravel. Например, can('impersonate',
      User::class).

3. Механизм переключения сессии:
    * Когда администратор вызывает этот маршрут, происходит ключевая логика:
        * Сохраняем ID администратора: Перед тем как "переключиться" на другого пользователя, система должна сохранить ID текущего администратора в сессии. Это "билет" для возвращения обратно. Например:
          session()->put('impersonator_id', auth()->id());.
        * Логинимся под пользователем: Laravel позволяет легко авторизоваться под любым пользователем: auth()->loginUsingId($user->id);.
        * Аудит: Это действие обязательно должно логироваться. В журнал записывается, какой администратор, в какое время и под каким пользователем авторизовался. Это критически важно для безопасности.

Б. Завершение имперсонации (Возвращение к своей учетной записи)

1. Создание маршрута для возврата:
    * Нужен еще один маршрут, например, POST /api/v1/users/impersonate/stop.

2. Логика возврата:
    * Когда вызывается этот маршрут:
        * Проверяем сессию: Система ищет в сессии ключ impersonator_id.
        * Возвращаем администратора: Если ключ найден, система использует этот ID, чтобы снова авторизовать администратора: auth()->loginUsingId(session('impersonator_id'));.
        * Очищаем сессию: После успешного возвращения ключ impersonator_id удаляется из сессии: session()->forget('impersonator_id');.
        * Аудит: Это действие также логируется.

2. Фронтенд (Vue UI)

1. Кнопка "Войти как пользователь":
    * В компоненте UserActions.vue (меню действий для каждой строки таблицы) добавляется новая опция, например, "Войти как пользователь" с иконкой.
    * При нажатии на эту кнопку отправляется API-запрос на маршрут POST /api/v1/users/{user}/impersonate.

2. Перенаправление:
    * После успешного ответа от API (код 200 OK), фронтенд должен просто перезагрузить страницу или перенаправить пользователя на главную (window.location.href = '/dashboard'). Поскольку сессия на бэкенде
      уже изменена, после перезагрузки администратор увидит приложение глазами выбранного пользователя.

3. Индикатор режима имперсонации:
    * Когда администратор находится в режиме имперсонации, он должен это четко видеть.
    * На бэкенде: API (например, при запросе /api/v1/user) должен возвращать информацию о том, что сессия является имперсонифицированной (например, is_impersonating: true и данные оригинального
      администратора).
    * На фронтенде: Если is_impersonating: true, по всему сайту отображается заметный баннер, например, вверху экрана. На баннере должно быть написано что-то вроде: "Вы вошли как Иван Иванов. [Вернуться в
      свою учетную запись]".

4. Кнопка "Вернуться":
    * Кнопка "Вернуться" на этом баннере отправляет запрос на POST /api/v1/users/impersonate/stop.
    * После успешного ответа страница снова перезагружается, баннер исчезает, и администратор видит приложение уже под своей учетной записью.

Итог (краткий флоу)

1. Админ нажимает кнопку "Войти как" в строке с Пользователем А.
2. Фронтенд отправляет запрос на бэкенд: "Админ хочет войти как Пользователь А".
3. Бэкенд проверяет, что это админ, сохраняет ID админа в сессию, и меняет текущего пользователя сессии на Пользователя А.
4. Фронтенд, получив "ОК", перезагружает страницу.
5. Теперь Админ видит сайт как Пользователь А. Вверху страницы висит баннер "Вы вошли как Пользователь А. [Вернуться]".
6. Админ нажимает "Вернуться".
7. Фронтенд шлет запрос "завершить имперсонацию".
8. Бэкенд находит ID админа в сессии, меняет пользователя сессии обратно на админа и чистит "билет".
9. Фронтенд, получив "ОК", перезагружает страницу. Админ снова видит сайт под своим аккаунтом.
